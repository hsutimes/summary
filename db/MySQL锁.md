> 来源：http://www.phpddt.com/db/mysql-locking.html

### 1.概括
MySQL的锁机制比较简单，最显著的特点是不同的搜索引擎支持不同的锁机制。比如，MyISAM和Memory存储引擎采用的是表级锁(table-level locking);InnoDB存储引擎即支持行级锁(row-level locking)，也支持表级锁，默认采用行级锁.  
MySQL3种锁的特性：

1. 表级锁  
开销小，加锁快；不会出现死锁；锁定粒度大，发成锁冲突的概率最高，并发度最低
2. 行级锁
开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高
3. 页面锁

表级锁适合于以查询为主，只有少量按索引条件更新数据的应用。如web应用。而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有兵法查询的应用，如一些在线事务处理（OLTP）系统。

### 2.MyISAM表锁
只支持表锁。  
执行select前，会自动给涉及的所有表加读锁  
执行更新操作(update/delete/insert)前，会自动给涉及的表加写锁

#### 2.1.查询表锁争用情况
通过检查`table_locks_waited`和`table_locks_immediate`状态变量，分析系统上的表锁定争夺

```sql
mysql>show status like `table%`;
```

#### 2.2.MySQL表锁的锁模式 
表锁模式有两种:

- `表共享读锁`(Table Read Lock)
- `表独占写锁`(Table Write Lock) 

MyISAM在执行Select前，会自动给涉及的所有表加读锁，在执行更新操作(update、delete、insert)前，会自动给涉及的表加写锁  
所以对MyISAM表进行操作，情况如下：

- 对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作
- 对MyISAM表的写操作（加写锁）,会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作

#### 2.3. 并发插入
原则上，数据表有一个读锁时，其他进程无法对此表进行更新操作，但在一定条件下，MyISAM表也支持查询和插入操作的并发进行
MyISAM存储引擎有一个系统变量`concurrent_insert`，专门用以控制其并发插入的行为，其值分别可以为0、1或2:

- 当`concurrent_insert`设置为0时，不允许并发插入
- 当`concurrent_insert`设置为1时，如果MyISAM表没有空洞（即表的中间没有被删除的行）,MyISAM允许在一个进程读表的时候，另一个进程从表尾插入纪录。这也是MySQL的默认设置
- 当`concurrent_insert`设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入纪录
	 
#### 2.4. MyISAM的锁调度
由于MySQL认为写请求一般比读请求更重要，所以如果有读写请求同时进行的话，MySQL将会优先执行写操作。这样MyISAM表在进行大量的更新操作时（特别是更新的字段存在索引的情况下），会造成查询操作很难获得读锁，从而导致查询阻塞.
调节MyISAM的调度行为：  

- 通过指定启动参数`low-priority-updates`,使MyISAM引擎默认给予`读请求`以优先的权利  
- 通过执行命令`set LOW_PRIORITY_UPDATES=1`,使该连接发出的更新请求优先级降低
- 通过指定insert\update\delete语句的`low_priority`属性，降低该语句的优先级

上面3种方法都是要么更新优先，要么查询优先的方法，不要盲目的给MySQL设置为读优先，因为一些需要长时间运行的查询操作，也会使写进程"饿死"。这些方法没有从根本上同时解决查询和更新的问题

在一个有大数据量、高并发表的MySQL里，可以通过**MySQL主从（读写）分离**来实现负载均衡，这样可以避免优先哪一种操作从而可能导致另一种操作的堵塞。
### 3.InnoDB行锁
InnoDB实现了两种类型的行锁：

1. 共享锁(S):  
允许一个事务去读一行。阻止其他事务获得相同数据集的排他锁  
2. 排他锁(X):  
允许获得排他锁的事务更新数据。阻止其他事务取得相同数据集的共享读锁和排他写锁

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁(Intention Locks)，这两种意向锁都是表锁

1. 意向共享锁(IS):  
事务打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该锁的IS锁  
2. 意向排他锁(IX):  
事务打算给数据行加行排他锁。事务在给一个数据行加排他锁前必须先取得该表的IX锁

请求锁模式  | X | IX | S | IS |
------------- | ------------- | ------------- | ------------- | ------------- |
当前锁模式 | 是否兼容 |
X | 冲突 | 冲突 | 冲突 | 冲突 |
IX | 冲突 | 兼容 | 冲突 | 兼容 |
S | 冲突 | 冲突 | 兼容 | 兼容 |
IS | 冲突 | 兼容 | 兼容 | 兼容 |

如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务。如果两者不兼容，该事务就要等待锁释放。

意向锁是InnoDB自动加的，不需用户干预。对于update\delete\insert语句，InnoDB会自动给涉及数据集加排他锁(X)，对于普通select语句，InnoDB不会加任何锁，事务可以通过以下语句显示给纪录集加共享锁或排他锁。

* 共享锁(S):select * from table_name where ... LOCK IN SHARE MODE
* 排他锁(X):select * from table_name where ... FOR UPDATE.

用select获得共享锁，主要用在需要数据依存关系时，来确认某行纪录是否存在，并确保没有人对这个纪录进行update或delete操作。但是如果当前事务也需要对该纪录进行更新操作，则很有可能造成死锁，对于锁定行纪录后需要进行更新操作的应用，应该使用select ... FOR UPDATE方式获得排他锁。
